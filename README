# genr

Simple concurrency with minimum mental overhead.

Builds on `concurrent.futures`, and uses `return value` in a generator, limiting use to Python 3.3 and above.

## Usage

### `yield` as a synchronization point

Functions and generators with `genr` decorator are executed in a new thread, with a special handling of the `yield`s. For example, in the following:

    @genr
    def example1():
        task1()
        task2()
        yield
        task3()
        
Tasks 1 and 2, also decorated with `genr`, are executed in parallel. `yield` waits until they are both complete, after which task 3 gets to run.

End of the function also acts as a collection  point, i.e. we wait for all called functions to complete before returning. Thus, in the example above, there is little practical difference whether `task3` is decorated with `genr` or not.

### Yielding results

Decorated functions return a `concurrent.futures` `Future`, which can be used in the usual way. You can also use a Tornado-inspired way of `yield`ing the result, like in this classical example of retrieving several web pages in parallel:

    @genr
    def example2():
        return yield [ fetch(url)
            for url in (
                'https://python.org',
                'https://pypi.org'
            )]
        
    @genr
    def fetch(url):
        return requests.get(url).text

### Ad hoc threads

Being a decorator, `genr` can be used to start parallel execution of individual functions inline, with the following syntax:

    genr(func_name)(param1, param2, ...)

While this avoids having to create named one-line functions just for the sake of parallel execution, the syntax is not especially readable, and quickly becomes untenable if you need to add timeouts, exception management etc.
                        
### Interrupting execution
        
Aligned with `concurrent.futures`, `genr` plays nice with being `KeyboardInterrupt`ed. To wait for a `genr` thread to complete in the main thread, you can sinply wait for the result:

    example().result()

## Discussion

### Pros

### Cons

- Minimum cognitive load, no need to even understand the concept of a future
- No need to prime loops etc.
- As effortless coexistence between sync and async code as possible
- Same decorator for simple threads, multiple parallel threads with common completion, with results and without results
- Timeouts for when things go wrong?
